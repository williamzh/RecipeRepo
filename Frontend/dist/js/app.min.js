var recipeRepoApp = angular.module("recipeRepoApp", [ "ui.router", "ui.bootstrap", "recipeRepoControllers", "recipeRepoDirectives", "recipeRepoServices" ]), recipeRepoControllers = angular.module("recipeRepoControllers", []), recipeRepoDirectives = angular.module("recipeRepoDirectives", []), recipeRepoServices = angular.module("recipeRepoServices", []);

recipeRepoApp.config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise("/"), $stateProvider.state("home", {
        "abstract": !0,
        url: "/",
        templateUrl: "app/components/home/home.html"
    }).state("home.topList", {
        url: "",
        templateUrl: "app/components/home/_top-list.html"
    }).state("home.search", {
        params: {
            query: null
        },
        templateUrl: "app/components/home/_search.html"
    }).state("home.favorites", {
        templateUrl: "app/components/home/_favorites.html"
    }).state("recipe", {
        url: "/recipe/:recipeId",
        templateUrl: "/app/components/recipe/recipe-details.html"
    }).state("manage", {
        url: "/manage",
        templateUrl: "/app/components/manage/manage-recipe.html"
    }).state("manage/edit", {
        url: "/manage/:recipeId",
        templateUrl: "/app/components/manage/manage-recipe.html"
    });
} ]), recipeRepoControllers.controller("homeController", [ "$scope", "$state", function($scope, $state) {
    $scope.forwardSearch = function() {
        $state.go("home.search", {
            query: $scope.searchQuery
        });
    };
} ]), recipeRepoControllers.controller("searchController", [ "$scope", "$stateParams", "apiClient", function($scope, $stateParams, apiClient) {
    $scope.searchQuery = $stateParams.query, $scope.search = function() {
        $scope.searchQuery && apiClient.searchRecipes($scope.searchQuery).then(function(hits) {
            $scope.hits = hits;
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("topListController", [ "$scope", "$state", "apiClient", function($scope, $state, apiClient) {
    $scope.getTopRecipes = function() {
        apiClient.getRecipes().then(function(recipes) {
            $scope.recipes = recipes.to(5);
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("manageRecipeController", [ "$scope", "$q", "$stateParams", "apiClient", "log", function($scope, $q, $stateParams, apiClient, log) {
    function fillData(recipe) {
        $scope.currentRecipe.name = recipe.recipeName, $scope.currentRecipe.description = recipe.description, 
        $scope.currentRecipe.imagePath = recipe.imagePath, $scope.currentRecipe.servings = recipe.servingSize, 
        $scope.currentRecipe.isFavorite = recipe.isFavorite, $scope.currentRecipe.rating = recipe.rating, 
        $scope.currentRecipe.ingredients = recipe.ingredients, $scope.currentRecipe.method = recipe.method.map(function(step) {
            return {
                value: step
            };
        }), $scope.currentRecipe.cuisine = recipe.meta.cuisine, $scope.currentRecipe.category = recipe.meta.category;
    }
    function formatData() {
        return {
            recipeName: $scope.currentRecipe.name,
            description: $scope.currentRecipe.description || "",
            imagePath: $scope.currentRecipe.imagePath || "",
            servingSize: $scope.currentRecipe.servings,
            isFavorite: $scope.currentRecipe.isFavorite || !1,
            rating: $scope.currentRecipe.rating,
            ingredients: $scope.currentRecipe.ingredients.map(function(ing) {
                return {
                    name: ing.name,
                    quantity: ing.quantity,
                    unit: ing.unit,
                    component: ing.component
                };
            }),
            method: $scope.currentRecipe.method.map(function(step) {
                return step.value;
            }),
            meta: {
                cuisine: $scope.currentRecipe.cuisine,
                category: $scope.currentRecipe.category
            }
        };
    }
    $scope.recipeId = $stateParams.recipeId, $scope.inEditMode = void 0 != $stateParams.recipeId, 
    $scope.currentRecipe = {
        ingredients: [ {} ],
        method: [ {} ]
    }, $scope.previousState = $scope.inEditMode ? "recipe" : "home.topList", $scope.init = function() {
        var initPromises = [ apiClient.getMetainfo() ];
        $scope.inEditMode && initPromises.push(apiClient.getRecipe($scope.recipeId)), $q.all(initPromises).then(function(responses) {
            var recipe = (responses[0], responses[1]);
            recipe && ($scope.recipe = fillData(recipe));
        })["catch"](function() {
            $scope.hasError = !0;
        });
    }, $scope.removeRow = function(index, model) {
        model.splice(index, 1);
    }, $scope.insertRowBelow = function(index, model) {
        model.splice(index + 1, 0, {});
    }, $scope.onSubmit = function(isValid) {
        if (isValid) if ($scope.inEditMode) {
            var updatedRecipe = formatData();
            updatedRecipe.id = $scope.recipeId, apiClient.updateRecipe(updatedRecipe).then(function() {
                $scope.recipeUpdated = !0;
            })["catch"](function() {
                $scope.showError = !0;
            });
        } else {
            var recipe = formatData();
            apiClient.addRecipe(recipe).then(function() {
                $scope.recipeCreated = !0;
            })["catch"](function() {
                $scope.showError = !0, $scope.recipeForm.$setPristine(), $scope.submitted = !1, 
                $scope.currentRecipe = {
                    ingredients: [ {} ],
                    method: [ {} ]
                };
            });
        }
    }, $scope.hasError = function(field) {
        var isInvalid = $scope.recipeForm[field].$invalid;
        return $scope.recipeForm[field].$dirty && isInvalid || $scope.submitted && isInvalid;
    };
} ]), recipeRepoControllers.controller("recipeDetailsController", [ "$scope", "$q", "$stateParams", "apiClient", function($scope, $q, $stateParams, apiClient) {
    function formatRecipe(recipe, metainfo) {
        recipe.groupedIngredients = recipe.ingredients.groupBy(function(ing) {
            return ing.component;
        });
        for (var metaKey in recipe.meta) {
            var metaId = recipe.meta[metaKey], metaName = metainfo[metaKey][metaId].name;
            recipe.meta[metaKey] = metaName;
        }
        return recipe;
    }
    $scope.getRecipe = function() {
        $q.all([ apiClient.getRecipe($stateParams.recipeId), apiClient.getMetainfo() ]).then(function(responses) {
            var recipe = responses[0], metainfo = responses[1];
            $scope.recipe = formatRecipe(recipe, metainfo), $scope.isAuthenticated = !0, $scope.hasError = !1;
        })["catch"](function() {
            $scope.hasError = !0;
        });
    }, $scope.onFavoriteClick = function(e) {
        var recipe = angular.copy($scope.recipe);
        recipe.isFavorite = !recipe.isFavorite, apiClient.updateRecipe(recipe).then(function(response) {
            $scope.recipe.isFavorite = recipe.isFavorite;
        });
    };
} ]);

var Config = {
    appServerUrl: "localhost:8001"
};

recipeRepoDirectives.directive("rdBackLink", [ "$window", "$state", function($window, $state) {
    return {
        restrict: "AE",
        scope: {
            targetState: "@?",
            targetStateEval: "=?",
            targetParams: "=?"
        },
        link: function(scope, elem) {
            elem.on("click", function() {
                return scope.targetState ? void $state.go(scope.targetState, scope.targetParams) : void $window.history.back();
            });
        },
        template: '<a class="back"><i class="fa fa-chevron-left"></i> Back</a>'
    };
} ]), recipeRepoDirectives.directive("rdNavbar", [ "$window", function($window) {
    return {
        restrict: "AE",
        controller: [ "$scope", "$location", "apiClient", function($scope, $location, apiClient) {
            $scope.isAuthenticated = !0, $scope.onSearchSelect = function($item, $model, $label) {
                $location.path("/recipes/" + $item.id);
            };
        } ],
        link: function(scope, elem, attrs) {
            elem.find(".back-btn").on("click", function() {
                $window.history.back();
            });
        },
        templateUrl: "/app/shared/navbar/_navbar.html"
    };
} ]), recipeRepoDirectives.directive("rdScroll", function() {
    return {
        restrict: "A",
        link: function(scope, $elem, $attr) {
            $elem.on("click", function() {
                var scrollPosition;
                switch ($attr.scrollTarget) {
                  case "top":
                    scrollPosition = $("body").offset().top;
                    break;

                  case "self":
                    scrollPosition = $elem.offset().top;
                    break;

                  default:
                    throw new Error("Invalid scroll target " + scope.target + ".");
                }
                $("body").animate({
                    scrollTop: scrollPosition
                }, 300);
            });
        }
    };
}), recipeRepoDirectives.directive("rdTabGroup", [ "$rootScope", function($rootScope) {
    return {
        restrict: "E",
        link: function(scope, elem) {
            function setActive(el) {
                elem.find("li").removeClass("active"), el.addClass("active");
            }
            elem.on("click", "li", function() {
                setActive($(this));
            }), $rootScope.$on("$stateChangeSuccess", function(event, toState) {
                var target = elem.find("li").filter(function(i, el) {
                    return $(el).children("a").attr("ui-sref") == toState.name;
                });
                target.length && setActive(target.eq(0));
            });
        },
        templateUrl: "/app/shared/tab-group/_tab-group.html"
    };
} ]), recipeRepoServices.factory("apiClient", [ "$http", "$q", "log", function($http, $q, log) {
    function getRecipes() {
        var url = baseUrl + "/recipes";
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getRecipes");
            return log.error(errMsg), errMsg;
        });
    }
    function getRecipe(id) {
        var url = baseUrl + "/recipes/" + id;
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getRecipe");
            throw new Error(errMsg);
        });
    }
    function addRecipe(recipe) {
        var url = baseUrl + "/recipes";
        return $http.post(url, {
            recipe: recipe
        }).then(function(response) {
            return response;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "addRecipe");
            throw new Error(errMsg);
        });
    }
    function updateRecipe(recipe) {
        var url = baseUrl + "/recipes/" + recipe.id;
        return $http.post(url, {
            recipe: recipe
        }).then(function(response) {
            return response;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "updateRecipe");
            throw new Error(errMsg);
        });
    }
    function searchRecipes(query) {
        var url = baseUrl + "/recipes/search";
        return $http.post(url, {
            query: query
        }).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "searchRecipes");
            throw new Error(errMsg);
        });
    }
    function getMetainfo() {
        var url = baseUrl + "/meta";
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getMetainfoKeys");
            throw new Error(errMsg);
        });
    }
    function onError(httpError, methodName) {
        var errorMessage = "object" == typeof httpError.data ? httpError.data.error : httpError.data;
        return log.error("API call " + methodName + "() failed with HTTP status " + httpError.status + ": " + errorMessage), 
        errorMessage;
    }
    var baseUrl = "http://{1}/api".assign(Config.appServerUrl);
    return {
        getRecipes: getRecipes,
        getRecipe: getRecipe,
        addRecipe: addRecipe,
        updateRecipe: updateRecipe,
        searchRecipes: searchRecipes,
        getMetainfo: getMetainfo
    };
} ]), recipeRepoServices.service("log", [ "$log", function($log) {
    this.info = function(message) {
        $log.info(message);
    }, this.warn = function(message) {
        $log.warn(message);
    }, this.error = function(message) {
        "string" == typeof message ? $log.error(message) : $log.error("Cannot log error - illegal message type.");
    }, this.errorFormat = function(template) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.error(template.assign.apply(template, args));
    }, this.debug = function(message) {
        $log.debug(message);
    };
} ]);