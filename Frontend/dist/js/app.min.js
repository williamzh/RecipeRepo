var recipeRepoApp = angular.module("recipeRepoApp", [ "ui.router", "ui.bootstrap", "recipeRepoControllers", "recipeRepoDirectives", "recipeRepoServices" ]), recipeRepoControllers = angular.module("recipeRepoControllers", []), recipeRepoDirectives = angular.module("recipeRepoDirectives", []), recipeRepoServices = angular.module("recipeRepoServices", []);

recipeRepoApp.config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise("/home"), $stateProvider.state("home", {
        url: "/",
        templateUrl: "app/components/home/home.html",
        controller: "homeCtrl"
    });
} ]), recipeRepoControllers.controller("homeCtrl", [ "$scope", "apiClient", function($scope, apiClient) {
    $scope.search = function(searchValue) {
        return apiClient.searchRecipes(searchValue).then(function(hits) {
            return hits;
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("ManageRecipeCtrl", [ "$scope", "$routeParams", "apiClient", "log", function($scope, $routeParams, apiClient, log) {
    function initEmptyRecipe() {
        $scope.currentRecipe = {
            ingredients: [ {} ],
            method: [ {} ]
        };
    }
    function fillData(recipe) {
        $scope.currentRecipe.name = recipe.recipeName, $scope.currentRecipe.description = recipe.description, 
        $scope.currentRecipe.imagePath = recipe.imagePath, $scope.currentRecipe.servings = recipe.servingSize, 
        $scope.currentRecipe.isFavorite = recipe.isFavorite, $scope.currentRecipe.ingredients = recipe.ingredients, 
        $scope.currentRecipe.method = recipe.method.map(function(step) {
            return {
                value: step
            };
        }), $scope.currentRecipe.cuisine = recipe.meta.cuisine, $scope.currentRecipe.category = recipe.meta.category, 
        $scope.currentRecipe.rating = recipe.meta.rating;
    }
    function formatData() {
        return {
            recipeName: $scope.currentRecipe.name,
            description: $scope.currentRecipe.description || "",
            imagePath: $scope.currentRecipe.imagePath || "",
            servingSize: $scope.currentRecipe.servings,
            isFavorite: $scope.currentRecipe.isFavorite || !1,
            rating: $scope.currentRecipe.rating,
            ingredients: $scope.currentRecipe.ingredients.map(function(ing) {
                return {
                    name: ing.name,
                    quantity: ing.quantity,
                    unit: ing.unit,
                    component: ing.component
                };
            }),
            method: $scope.currentRecipe.method.map(function(step) {
                return step.value;
            }),
            meta: {
                cuisine: $scope.currentRecipe.cuisine,
                category: $scope.currentRecipe.category
            }
        };
    }
    $scope.mode = "create", initEmptyRecipe(), $scope.alerts = {
        created: {
            type: "success",
            msg: "Recipe successfully created."
        },
        updated: {
            type: "success",
            msg: "Recipe successfully updated."
        },
        error: {
            type: "danger",
            msg: "Oh snap, an unexpected error occured. Please contact [responsible person here]."
        }
    }, apiClient.getMetaData().then(function(metaData) {
        var cuisineMeta = metaData.cuisine;
        $scope.cuisines = cuisineMeta ? cuisineMeta.values : [];
        var categoryMeta = metaData.category;
        $scope.categories = categoryMeta ? categoryMeta.values : [], $routeParams.recipeId && ($scope.mode = "edit", 
        apiClient.getRecipe($routeParams.recipeId).then(function(recipe) {
            fillData(recipe);
        }));
    }), $scope.removeRow = function(index, model) {
        model.splice(index, 1);
    }, $scope.insertRowBelow = function(index, model) {
        model.splice(index + 1, 0, {});
    }, $scope.onSubmit = function(isValid) {
        if (isValid) {
            var recipe = formatData();
            if ("create" == $scope.mode) apiClient.addRecipe(recipe).then(function() {
                $scope.activeAlert = "created";
            }, function() {
                $scope.activeAlert = "error";
            }), $scope.recipeForm.$setPristine(), $scope.submitted = !1, initEmptyRecipe(); else if ("edit" == $scope.mode) {
                var updatedRecipe = formatData();
                updatedRecipe.id = $routeParams.recipeId, apiClient.updateRecipe(updatedRecipe).then(function() {
                    $scope.activeAlert = "updated";
                }, function() {
                    $scope.activeAlert = "error";
                });
            } else log.errorFormat("Failed to create or update recipe. Unknown mode {1}.", $scope.mode);
        }
    }, $scope.hasError = function(field) {
        var isInvalid = $scope.recipeForm[field].$invalid;
        return $scope.recipeForm[field].$dirty && isInvalid || $scope.submitted && isInvalid;
    };
} ]), recipeRepoControllers.controller("RecipeDetailsCtrl", [ "$scope", "$routeParams", "apiClient", function($scope, $routeParams, apiClient) {
    function appendGroupIngredients(recipe) {
        return recipe.groupedIngredients = recipe.ingredients.groupBy(function(ing) {
            return ing.component;
        }), recipe;
    }
    apiClient.getRecipe($routeParams.recipeId).then(function(recipe) {
        $scope.recipe = appendGroupIngredients(recipe), $scope.isAuthenticated = !0, $scope.hasError = !1;
    }, function() {
        $scope.hasError = !0;
    }), $scope.onFavoriteClick = function(e) {
        var recipe = angular.copy($scope.recipe);
        recipe.isFavorite = !recipe.isFavorite, apiClient.updateRecipe(recipe).then(function(response) {
            $scope.recipe.isFavorite = recipe.isFavorite;
        });
    };
} ]), recipeRepoControllers.controller("RecipeListCtrl", [ "$scope", "apiClient", function($scope, apiClient) {
    apiClient.requestMany(apiClient.getRecipes("category"), apiClient.getMetaData()).then(function(results) {
        $scope.categories = results[0];
        var keysObj = results[1].category;
        if (keysObj) {
            var keys = Object.keys(keysObj.values);
            $scope.groupKeys = keys.map(function(key) {
                return {
                    display: key.capitalize(),
                    value: key
                };
            });
        } else $scope.groupKeys = [];
        $scope.selectedGrouping = $scope.groupKeys[0];
    })["catch"](function() {
        $scope.showErrorAlert = !0;
    }), $scope.updateRecipeGrouping = function() {
        apiClient.getRecipes($scope.selectedGrouping.value).then(function(categories) {
            $scope.categories = categories;
        });
    };
} ]);

var Config = {
    appServerUrl: "recipereposerver.dev.local"
};

recipeRepoDirectives.directive("rdNavbar", [ "$window", function($window) {
    return {
        restrict: "AE",
        controller: [ "$scope", "$location", "apiClient", function($scope, $location, apiClient) {
            $scope.isAuthenticated = !0, $scope.onSearchSelect = function($item, $model, $label) {
                $location.path("/recipes/" + $item.id);
            };
        } ],
        link: function(scope, elem, attrs) {
            elem.find(".back-btn").on("click", function() {
                $window.history.back();
            });
        },
        templateUrl: "/app/shared/navbar/_navbar.html"
    };
} ]), recipeRepoDirectives.directive("rdRating", function() {
    return {
        restrict: "A",
        scope: {
            ratingvalue: "@"
        },
        controller: [ "$scope", function($scope) {
            for (var maxStars = 5, fullStars = Math.floor($scope.ratingvalue), hasHalfStar = $scope.ratingvalue - fullStars > 0, starClasses = [], i = 0; maxStars > i; i++) fullStars > i ? starClasses.push("star") : hasHalfStar ? (starClasses.push("star-half-full"), 
            hasHalfStar = !1) : starClasses.push("star-o");
            $scope.starClasses = starClasses;
        } ],
        template: '<span ng-repeat="starClass in starClasses track by $index" class="fa fa-{{starClass}}">'
    };
}), recipeRepoDirectives.directive("rdScroll", function() {
    return {
        restrict: "A",
        link: function(scope, $elem, $attr) {
            $elem.on("click", function() {
                var scrollPosition;
                switch ($attr.scrollTarget) {
                  case "top":
                    scrollPosition = $("body").offset().top;
                    break;

                  case "self":
                    scrollPosition = $elem.offset().top;
                    break;

                  default:
                    throw new Error("Invalid scroll target " + scope.target + ".");
                }
                $("body").animate({
                    scrollTop: scrollPosition
                }, 300);
            });
        }
    };
}), recipeRepoServices.factory("apiClient", [ "$http", "$q", "log", function($http, $q, log) {
    function getRecipes(groupBy) {
        var url = baseUrl + "/recipes";
        return groupBy && (url += "?groupBy=" + groupBy), $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getRecipes");
            throw new Error(errMsg);
        });
    }
    function getRecipe(id) {
        var url = baseUrl + "/recipes/" + id;
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getRecipe");
            throw new Error(errMsg);
        });
    }
    function addRecipe(recipe) {
        var url = baseUrl + "/recipes";
        return $http.post(url, {
            recipe: recipe
        }).then(function(response) {
            return response;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "addRecipe");
            throw new Error(errMsg);
        });
    }
    function updateRecipe(recipe) {
        var url = baseUrl + "/recipes/" + recipe.id;
        return $http.post(url, {
            recipe: recipe
        }).then(function(response) {
            return response;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "updateRecipe");
            throw new Error(errMsg);
        });
    }
    function searchRecipes(query) {
        var url = baseUrl + "/recipes/search";
        return $http.post(url, {
            query: query
        }).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "searchRecipes");
            throw new Error(errMsg);
        });
    }
    function getMetaData() {
        var url = baseUrl + "/meta";
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getMetainfoKeys");
            throw new Error(errMsg);
        });
    }
    function requestMany() {
        return $q.all(arguments).then(function(results) {
            return results;
        });
    }
    function onError(httpError, methodName) {
        var errorMessage = "object" == typeof httpError.data ? httpError.data.error : httpError.data;
        return log.error("API call " + methodName + "() failed with HTTP status " + httpError.status + ": " + errorMessage), 
        errorMessage;
    }
    var baseUrl = "http://{1}/api".assign(Config.appServerUrl);
    return {
        getRecipes: getRecipes,
        getRecipe: getRecipe,
        addRecipe: addRecipe,
        updateRecipe: updateRecipe,
        searchRecipes: searchRecipes,
        getMetaData: getMetaData,
        requestMany: requestMany
    };
} ]), recipeRepoServices.service("log", [ "$log", function($log) {
    this.info = function(message) {
        $log.info(message);
    }, this.warn = function(message) {
        $log.warn(message);
    }, this.error = function(message) {
        "string" == typeof message ? $log.error(message) : $log.error("Cannot log error - illegal message type.");
    }, this.errorFormat = function(template) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.error(template.assign.apply(template, args));
    }, this.debug = function(message) {
        $log.debug(message);
    };
} ]);