var recipeRepoApp = angular.module("recipeRepoApp", [ "ui.router", "ui.bootstrap", "ngStorage", "recipeRepoControllers", "recipeRepoDirectives", "recipeRepoServices" ]), recipeRepoControllers = angular.module("recipeRepoControllers", []), recipeRepoDirectives = angular.module("recipeRepoDirectives", []), recipeRepoServices = angular.module("recipeRepoServices", []);

recipeRepoApp.run([ "localizationInitializer", function(localizationInitializer) {
    localizationInitializer.load();
} ]), recipeRepoApp.config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise("/"), $stateProvider.state("home", {
        "abstract": !0,
        url: "/",
        templateUrl: "app/components/home/home.html"
    }).state("home.start", {
        url: "",
        templateUrl: "app/components/home/_start.html"
    }).state("home.search", {
        resolve: {
            searchQueryProvider: "searchQueryProvider"
        },
        params: {
            query: null
        },
        templateUrl: "app/components/home/_search.html"
    }).state("home.favorites", {
        templateUrl: "app/components/home/_favorites.html"
    }).state("recipe", {
        url: "/recipe/:recipeId",
        templateUrl: "/app/components/recipe/recipe-details.html"
    }).state("manage", {
        url: "/manage",
        templateUrl: "/app/components/manage/manage-recipe.html"
    }).state("manage/edit", {
        url: "/manage/:recipeId",
        templateUrl: "/app/components/manage/manage-recipe.html"
    });
} ]), recipeRepoControllers.controller("favoritesController", [ "$scope", "apiClient", function($scope, apiClient) {
    $scope.getFavoriteRecipes = function() {
        apiClient.getRecipes().then(function(recipes) {
            $scope.recipes = recipes.findAll(function(r) {
                return 1 == r.isFavorite;
            });
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("homeController", [ "$scope", "$state", function($scope, $state) {
    $scope.search = function() {
        $state.go("home.search", {
            query: $scope.searchQuery
        });
    };
} ]), recipeRepoControllers.controller("searchController", [ "$scope", "searchQueryProvider", "apiClient", function($scope, searchQueryProvider, apiClient) {
    $scope.searchQuery = searchQueryProvider.getValue(), $scope.searchQuery && apiClient.searchRecipes($scope.searchQuery).then(function(hits) {
        $scope.hits = hits;
    })["catch"](function() {});
} ]), recipeRepoControllers.controller("startController", [ "$scope", "$state", "apiClient", function($scope, $state, apiClient) {
    $scope.getTopRecipes = function() {
        apiClient.getRecipes().then(function(recipes) {
            $scope.recipes = recipes.to(5);
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("manageRecipeController", [ "$scope", "$q", "$stateParams", "apiClient", "localizationService", "log", function($scope, $q, $stateParams, apiClient, localizationService, log) {
    $scope.recipeId = $stateParams.recipeId, $scope.inEditMode = void 0 != $stateParams.recipeId, 
    $scope.currentRecipe = {
        meta: {}
    }, $scope.init = function() {
        var initPromises = [ apiClient.getMetainfo() ];
        $scope.inEditMode && initPromises.push(apiClient.getRecipe($scope.recipeId)), $q.all(initPromises).then(function(responses) {
            var metaInfo = responses[0], recipe = responses[1];
            recipe && ($scope.currentRecipe = recipe), $scope.cuisines = metaInfo.cuisines, 
            $scope.currentRecipe.meta.cuisine = $scope.cuisines[0], $scope.categories = metaInfo.categories, 
            $scope.currentRecipe.meta.category = $scope.categories[0], $scope.courses = metaInfo.courses, 
            $scope.currentRecipe.meta.course = $scope.courses[0];
        })["catch"](function() {
            $scope.hasError = !0;
        });
    }, $scope.getMetaLabel = function(value) {
        return localizationService.translate("metaTags", value);
    }, $scope.removeRow = function(index, model) {
        model.splice(index, 1);
    }, $scope.insertRow = function(index, model, initValue) {
        model.splice(index + 1, 0, initValue);
    }, $scope.onSubmit = function() {
        $scope.showError = !1, recipeForm.$invalid || ($scope.inEditMode ? ($scope.recipeUpdated = !1, 
        apiClient.updateRecipe($scope.currentRecipe).then(function() {
            $scope.recipeUpdated = !0, $scope.submitted = !1;
        })["catch"](function() {
            $scope.showError = !0;
        })) : ($scope.recipeCreated = !1, apiClient.addRecipe($scope.currentRecipe).then(function() {
            $scope.recipeCreated = !0, $scope.recipeForm.$setPristine(), $scope.submitted = !1, 
            $scope.currentRecipe = {
                ingredients: [ {} ],
                method: [ {} ]
            };
        })["catch"](function() {
            $scope.showError = !0;
        })));
    }, $scope.hasError = function(field) {
        var isInvalid = $scope.recipeForm[field].$invalid;
        return $scope.recipeForm[field].$dirty && isInvalid || $scope.submitted && isInvalid;
    };
} ]), recipeRepoControllers.controller("recipeDetailsController", [ "$scope", "$stateParams", "$state", "apiClient", "localizationService", function($scope, $stateParams, $state, apiClient, localizationService) {
    function formatRecipe(recipe) {
        recipe.groupedIngredients = recipe.ingredients.groupBy(function(ing) {
            return ing.component;
        });
        for (var metaType in recipe.meta) {
            var metaValue = recipe.meta[metaType];
            recipe.meta[metaType] = localizationService.translate("metaTags", metaValue);
        }
        return recipe;
    }
    $scope.modalHeading = localizationService.translate("recipeDetails", "confirmRemoveHeading"), 
    $scope.modalAction = localizationService.translate("recipeDetails", "confirmRemoveButton"), 
    $scope.getRecipe = function() {
        apiClient.getRecipe($stateParams.recipeId).then(function(recipe) {
            $scope.recipe = formatRecipe(recipe), $scope.isAuthenticated = !0, $scope.hasError = !1;
        })["catch"](function() {
            $scope.hasError = !0;
        });
    }, $scope.onFavoriteClick = function(e) {
        var recipe = angular.copy($scope.recipe);
        recipe.isFavorite = !recipe.isFavorite, apiClient.updateRecipe(recipe).then(function(response) {
            $scope.recipe.isFavorite = recipe.isFavorite;
        });
    }, $scope.removeRecipe = function() {
        apiClient.removeRecipe($scope.recipe.id).then(function() {
            $state.go("home.start");
        })["catch"](function() {
            $scope.hasError = !0;
        });
    };
} ]);

var Config = {
    appServerUrl: "localhost:8001"
};

recipeRepoDirectives.directive("rdAlert", [ "$window", function($window) {
    return {
        restrict: "E",
        scope: {
            type: "@",
            messageKey: "@",
            observe: "&"
        },
        link: function($scope, elem) {
            $scope.$watch($scope.observe, function(newValue, oldValue, scope) {
                $scope.visible = newValue === !0;
            }), elem.find(".close").on("click", function(e) {
                $scope.visible = !1, $scope.$apply();
            });
        },
        templateUrl: "/app/shared/alert/_alert.html"
    };
} ]), recipeRepoDirectives.directive("rdTranslate", function() {
    return {
        restrict: "AE",
        scope: {
            key: "@",
            attr: "@?"
        },
        controller: [ "$scope", "localizationService", function($scope, localizationService) {
            var keySegments = $scope.key.split("/");
            $scope.translatedValue = localizationService.translate(keySegments[0], keySegments[1]);
        } ],
        link: function(scope, elem, attrs) {
            var unwatch = scope.$watch("translatedValue", function(newValue) {
                newValue && (scope.attr ? elem.attr(scope.attr, newValue) : elem.text(newValue), 
                unwatch());
            });
        }
    };
}), recipeRepoServices.service("localizationInitializer", [ "$localStorage", "apiClient", function($localStorage, apiClient) {
    this.load = function() {
        apiClient.getTranslations().then(function(translations) {
            $localStorage.translations = translations;
        })["catch"](function(error) {
            throw Error("Fatal: could not get translations.");
        });
    };
} ]), recipeRepoServices.service("localizationService", [ "$localStorage", function($localStorage) {
    this.translate = function(area, key) {
        var translations = $localStorage.translations;
        if (translations) {
            var matchingArea = translations[area];
            if (matchingArea) {
                var matchingTranslation = matchingArea[key];
                if (matchingTranslation) return matchingTranslation;
            }
        }
        return "[{1}/{2}]".assign(area, key);
    };
} ]), recipeRepoDirectives.directive("rdModal", [ "$window", function($window) {
    return {
        restrict: "E",
        transclude: !0,
        scope: {
            targetId: "@",
            modalHeader: "@",
            actionLabel: "@",
            onAction: "&"
        },
        controller: [ "$scope", function($scope) {
            $scope.actionInvoking = !1, $scope.invokeAction = function() {
                $scope.actionInvoking = !0, $scope.onAction();
            };
        } ],
        link: function(scope, elem) {
            var unwatch = scope.$watch("actionInvoking", function(newValue) {
                newValue === !0 && ($("#" + scope.targetId).modal("hide"), unwatch());
            });
        },
        templateUrl: "/app/shared/modal/_modal.html"
    };
} ]), recipeRepoDirectives.directive("rdNavbar", [ "$window", function($window) {
    return {
        restrict: "AE",
        controller: [ "$scope", "$location", "apiClient", function($scope, $location, apiClient) {
            $scope.isAuthenticated = !0, $scope.onSearchSelect = function($item, $model, $label) {
                $location.path("/recipes/" + $item.id);
            };
        } ],
        link: function(scope, elem, attrs) {
            elem.find(".back-btn").on("click", function() {
                $window.history.back();
            });
        },
        templateUrl: "/app/shared/navbar/_navbar.html"
    };
} ]), recipeRepoDirectives.directive("rdBackLink", [ "$window", "$state", function($window, $state) {
    return {
        restrict: "AE",
        scope: {
            targetState: "@",
            targetParams: "=?"
        },
        link: function(scope, elem) {
            elem.on("click", function() {
                scope.targetState ? $state.go(scope.targetState, scope.targetParams) : $window.history.back();
            });
        },
        template: '<a class="back"><i class="fa fa-chevron-left"></i> <rd-translate key="global/backLabel"></rd-translate></a>'
    };
} ]), recipeRepoServices.service("searchQueryProvider", [ "$stateParams", function($stateParams) {
    this.getValue = function() {
        return $stateParams.query || angular.element("#recipe-search").val();
    };
} ]), recipeRepoDirectives.directive("rdScroll", function() {
    return {
        restrict: "A",
        link: function(scope, $elem, $attr) {
            $elem.on("click", function() {
                var scrollPosition;
                switch ($attr.scrollTarget) {
                  case "top":
                    scrollPosition = $("body").offset().top;
                    break;

                  case "self":
                    scrollPosition = $elem.offset().top;
                    break;

                  default:
                    throw new Error("Invalid scroll target " + scope.target + ".");
                }
                $("body").animate({
                    scrollTop: scrollPosition
                }, 300);
            });
        }
    };
}), recipeRepoServices.service("apiClient", [ "$http", "$q", "log", function($http, $q, log) {
    var baseUrl = "http://{1}/api".assign(Config.appServerUrl), onSuccess = function(action, response) {
        return log.debug(action + ": Successfully received response from API."), response.data;
    }, onError = function(action, error) {
        var errorMessage = error;
        return error.data && (errorMessage = error.data.message || error.data), log.error(action + ": an error occured (" + error.status + " " + error.statusText + "): " + errorMessage), 
        $q.reject({
            statusCode: error.status || -1,
            message: errorMessage
        });
    };
    this.getRecipes = function() {
        return $http.get(baseUrl + "/recipes").then(function(response) {
            return onSuccess("getRecipes", response);
        })["catch"](function(error) {
            return onError("getRecipes", error);
        });
    }, this.getRecipe = function(id) {
        return $http.get(baseUrl + "/recipes/" + id).then(function(response) {
            return onSuccess("getRecipe", response);
        })["catch"](function(error) {
            return onError("getRecipe", error);
        });
    }, this.addRecipe = function(recipe) {
        return $http.post(baseUrl + "/recipes", {
            recipe: recipe
        }).then(function(response) {
            return onSuccess("addRecipe", response);
        })["catch"](function(error) {
            return onError("addRecipe", error);
        });
    }, this.updateRecipe = function(recipe) {
        return $http.post(baseUrl + "/recipes/" + recipe.id, {
            recipe: recipe
        }).then(function(response) {
            return onSuccess("updateRecipe", response);
        })["catch"](function(error) {
            return onError("updateRecipe", error);
        });
    }, this.removeRecipe = function(recipeId) {
        return $http["delete"](baseUrl + "/recipes/" + recipeId).then(function(response) {
            return onSuccess("removeRecipe", response);
        })["catch"](function(error) {
            return onError("removeRecipe", error);
        });
    }, this.searchRecipes = function(query) {
        return $http.post(baseUrl + "/recipes/search", {
            query: query
        }).then(function(response) {
            return onSuccess("searchRecipes", response);
        })["catch"](function(error) {
            return onError("searchRecipes", error);
        });
    }, this.getMetainfo = function() {
        return $http.get(baseUrl + "/meta").then(function(response) {
            return onSuccess("getMetainfo", response);
        })["catch"](function(error) {
            return onError("getMetainfo", error);
        });
    }, this.getTranslations = function() {
        return $http.get(baseUrl + "/translations").then(function(response) {
            return onSuccess("translations", response);
        })["catch"](function(error) {
            return onError("translations", error);
        });
    };
} ]), recipeRepoServices.service("log", [ "$log", function($log) {
    this.info = function(message) {
        $log.info(message);
    }, this.warn = function(message) {
        $log.warn(message);
    }, this.error = function(message) {
        "string" == typeof message ? $log.error(message) : $log.error("Cannot log error - illegal message type.");
    }, this.errorFormat = function(template) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.error(template.assign.apply(template, args));
    }, this.debug = function(message) {
        $log.debug(message);
    };
} ]);