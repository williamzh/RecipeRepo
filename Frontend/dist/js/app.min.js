var recipeRepoApp = angular.module("recipeRepoApp", [ "ui.router", "ui.bootstrap", "recipeRepoControllers", "recipeRepoDirectives", "recipeRepoServices" ]), recipeRepoControllers = angular.module("recipeRepoControllers", []), recipeRepoDirectives = angular.module("recipeRepoDirectives", []), recipeRepoServices = angular.module("recipeRepoServices", []);

recipeRepoApp.config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise("/"), $stateProvider.state("home", {
        "abstract": !0,
        url: "/",
        templateUrl: "app/components/home/home.html"
    }).state("home.topList", {
        url: "",
        templateUrl: "app/components/home/_top-list.html"
    }).state("home.search", {
        params: {
            query: null
        },
        templateUrl: "app/components/home/_search.html"
    }).state("home.favorites", {
        templateUrl: "app/components/home/_favorites.html"
    }).state("recipe", {
        url: "/recipe/:recipeId",
        templateUrl: "/app/components/recipe/recipe-details.html"
    }).state("manage", {
        url: "/manage",
        templateUrl: "/app/components/manage/manage-recipe.html"
    }).state("manage/edit", {
        url: "/manage/:recipeId",
        templateUrl: "/app/components/manage/manage-recipe.html"
    });
} ]), recipeRepoControllers.controller("homeController", [ "$scope", "$state", function($scope, $state) {
    $scope.forwardSearch = function() {
        $state.go("home.search", {
            query: $scope.searchQuery
        });
    };
} ]), recipeRepoControllers.controller("searchController", [ "$scope", "$stateParams", "apiClient", function($scope, $stateParams, apiClient) {
    $scope.searchQuery = $stateParams.query, $scope.search = function() {
        $scope.searchQuery && apiClient.searchRecipes($scope.searchQuery).then(function(hits) {
            $scope.hits = hits;
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("topListController", [ "$scope", "$state", "apiClient", function($scope, $state, apiClient) {
    $scope.getTopRecipes = function() {
        apiClient.getRecipes().then(function(recipes) {
            $scope.recipes = recipes.to(5);
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("ManageRecipeCtrl", [ "$scope", "$routeParams", "apiClient", "log", function($scope, $routeParams, apiClient, log) {
    function initEmptyRecipe() {
        $scope.currentRecipe = {
            ingredients: [ {} ],
            method: [ {} ]
        };
    }
    function fillData(recipe) {
        $scope.currentRecipe.name = recipe.recipeName, $scope.currentRecipe.description = recipe.description, 
        $scope.currentRecipe.imagePath = recipe.imagePath, $scope.currentRecipe.servings = recipe.servingSize, 
        $scope.currentRecipe.isFavorite = recipe.isFavorite, $scope.currentRecipe.ingredients = recipe.ingredients, 
        $scope.currentRecipe.method = recipe.method.map(function(step) {
            return {
                value: step
            };
        }), $scope.currentRecipe.cuisine = recipe.meta.cuisine, $scope.currentRecipe.category = recipe.meta.category, 
        $scope.currentRecipe.rating = recipe.meta.rating;
    }
    function formatData() {
        return {
            recipeName: $scope.currentRecipe.name,
            description: $scope.currentRecipe.description || "",
            imagePath: $scope.currentRecipe.imagePath || "",
            servingSize: $scope.currentRecipe.servings,
            isFavorite: $scope.currentRecipe.isFavorite || !1,
            rating: $scope.currentRecipe.rating,
            ingredients: $scope.currentRecipe.ingredients.map(function(ing) {
                return {
                    name: ing.name,
                    quantity: ing.quantity,
                    unit: ing.unit,
                    component: ing.component
                };
            }),
            method: $scope.currentRecipe.method.map(function(step) {
                return step.value;
            }),
            meta: {
                cuisine: $scope.currentRecipe.cuisine,
                category: $scope.currentRecipe.category
            }
        };
    }
    $scope.mode = "create", initEmptyRecipe(), $scope.alerts = {
        created: {
            type: "success",
            msg: "Recipe successfully created."
        },
        updated: {
            type: "success",
            msg: "Recipe successfully updated."
        },
        error: {
            type: "danger",
            msg: "Oh snap, an unexpected error occured. Please contact [responsible person here]."
        }
    }, apiClient.getMetaData().then(function(metaData) {
        var cuisineMeta = metaData.cuisine;
        $scope.cuisines = cuisineMeta ? cuisineMeta.values : [];
        var categoryMeta = metaData.category;
        $scope.categories = categoryMeta ? categoryMeta.values : [], $routeParams.recipeId && ($scope.mode = "edit", 
        apiClient.getRecipe($routeParams.recipeId).then(function(recipe) {
            fillData(recipe);
        }));
    }), $scope.removeRow = function(index, model) {
        model.splice(index, 1);
    }, $scope.insertRowBelow = function(index, model) {
        model.splice(index + 1, 0, {});
    }, $scope.onSubmit = function(isValid) {
        if (isValid) {
            var recipe = formatData();
            if ("create" == $scope.mode) apiClient.addRecipe(recipe).then(function() {
                $scope.activeAlert = "created";
            }, function() {
                $scope.activeAlert = "error";
            }), $scope.recipeForm.$setPristine(), $scope.submitted = !1, initEmptyRecipe(); else if ("edit" == $scope.mode) {
                var updatedRecipe = formatData();
                updatedRecipe.id = $routeParams.recipeId, apiClient.updateRecipe(updatedRecipe).then(function() {
                    $scope.activeAlert = "updated";
                }, function() {
                    $scope.activeAlert = "error";
                });
            } else log.errorFormat("Failed to create or update recipe. Unknown mode {1}.", $scope.mode);
        }
    }, $scope.hasError = function(field) {
        var isInvalid = $scope.recipeForm[field].$invalid;
        return $scope.recipeForm[field].$dirty && isInvalid || $scope.submitted && isInvalid;
    };
} ]), recipeRepoControllers.controller("recipeDetailsController", [ "$scope", "$stateParams", "apiClient", function($scope, $stateParams, apiClient) {
    function appendGroupIngredients(recipe) {
        return recipe.groupedIngredients = recipe.ingredients.groupBy(function(ing) {
            return ing.component;
        }), recipe;
    }
    $scope.getRecipe = function() {
        apiClient.getRecipe($stateParams.recipeId).then(function(recipe) {
            $scope.recipe = appendGroupIngredients(recipe), $scope.isAuthenticated = !0, $scope.hasError = !1;
        }, function() {
            $scope.hasError = !0;
        });
    }, $scope.onFavoriteClick = function(e) {
        var recipe = angular.copy($scope.recipe);
        recipe.isFavorite = !recipe.isFavorite, apiClient.updateRecipe(recipe).then(function(response) {
            $scope.recipe.isFavorite = recipe.isFavorite;
        });
    };
} ]);

var Config = {
    appServerUrl: "localhost:8001"
};

recipeRepoDirectives.directive("rdNavbar", [ "$window", function($window) {
    return {
        restrict: "AE",
        controller: [ "$scope", "$location", "apiClient", function($scope, $location, apiClient) {
            $scope.isAuthenticated = !0, $scope.onSearchSelect = function($item, $model, $label) {
                $location.path("/recipes/" + $item.id);
            };
        } ],
        link: function(scope, elem, attrs) {
            elem.find(".back-btn").on("click", function() {
                $window.history.back();
            });
        },
        templateUrl: "/app/shared/navbar/_navbar.html"
    };
} ]), recipeRepoDirectives.directive("rdScroll", function() {
    return {
        restrict: "A",
        link: function(scope, $elem, $attr) {
            $elem.on("click", function() {
                var scrollPosition;
                switch ($attr.scrollTarget) {
                  case "top":
                    scrollPosition = $("body").offset().top;
                    break;

                  case "self":
                    scrollPosition = $elem.offset().top;
                    break;

                  default:
                    throw new Error("Invalid scroll target " + scope.target + ".");
                }
                $("body").animate({
                    scrollTop: scrollPosition
                }, 300);
            });
        }
    };
}), recipeRepoDirectives.directive("rdTabGroup", [ "$rootScope", function($rootScope) {
    return {
        restrict: "E",
        link: function(scope, elem) {
            function setActive(el) {
                elem.find("li").removeClass("active"), el.addClass("active");
            }
            elem.on("click", "li", function() {
                setActive($(this));
            }), $rootScope.$on("$stateChangeSuccess", function(event, toState) {
                var target = elem.find("li").filter(function(i, el) {
                    return $(el).children("a").attr("ui-sref") == toState.name;
                });
                target.length && setActive(target.eq(0));
            });
        },
        templateUrl: "/app/shared/tab-group/_tab-group.html"
    };
} ]), recipeRepoServices.factory("apiClient", [ "$http", "$q", "log", function($http, $q, log) {
    function getRecipes() {
        var url = baseUrl + "/recipes";
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getRecipes");
            return log.error(errMsg), errMsg;
        });
    }
    function getRecipe(id) {
        var url = baseUrl + "/recipes/" + id;
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getRecipe");
            throw new Error(errMsg);
        });
    }
    function addRecipe(recipe) {
        var url = baseUrl + "/recipes";
        return $http.post(url, {
            recipe: recipe
        }).then(function(response) {
            return response;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "addRecipe");
            throw new Error(errMsg);
        });
    }
    function updateRecipe(recipe) {
        var url = baseUrl + "/recipes/" + recipe.id;
        return $http.post(url, {
            recipe: recipe
        }).then(function(response) {
            return response;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "updateRecipe");
            throw new Error(errMsg);
        });
    }
    function searchRecipes(query) {
        var url = baseUrl + "/recipes/search";
        return $http.post(url, {
            query: query
        }).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "searchRecipes");
            throw new Error(errMsg);
        });
    }
    function getMetaData() {
        var url = baseUrl + "/meta";
        return $http.get(url).then(function(response) {
            return response.data;
        })["catch"](function(errorObj) {
            var errMsg = onError(errorObj, "getMetainfoKeys");
            throw new Error(errMsg);
        });
    }
    function requestMany() {
        return $q.all(arguments).then(function(results) {
            return results;
        });
    }
    function onError(httpError, methodName) {
        var errorMessage = "object" == typeof httpError.data ? httpError.data.error : httpError.data;
        return log.error("API call " + methodName + "() failed with HTTP status " + httpError.status + ": " + errorMessage), 
        errorMessage;
    }
    var baseUrl = "http://{1}/api".assign(Config.appServerUrl);
    return {
        getRecipes: getRecipes,
        getRecipe: getRecipe,
        addRecipe: addRecipe,
        updateRecipe: updateRecipe,
        searchRecipes: searchRecipes,
        getMetaData: getMetaData,
        requestMany: requestMany
    };
} ]), recipeRepoServices.service("log", [ "$log", function($log) {
    this.info = function(message) {
        $log.info(message);
    }, this.warn = function(message) {
        $log.warn(message);
    }, this.error = function(message) {
        "string" == typeof message ? $log.error(message) : $log.error("Cannot log error - illegal message type.");
    }, this.errorFormat = function(template) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.error(template.assign.apply(template, args));
    }, this.debug = function(message) {
        $log.debug(message);
    };
} ]);