var recipeRepoApp = angular.module("recipeRepoApp", [ "ui.router", "ui.bootstrap", "ngStorage", "recipeRepoControllers", "recipeRepoDirectives", "recipeRepoServices" ]), recipeRepoControllers = angular.module("recipeRepoControllers", []), recipeRepoDirectives = angular.module("recipeRepoDirectives", []), recipeRepoServices = angular.module("recipeRepoServices", []);

recipeRepoApp.config([ "$httpProvider", function($httpProvider) {
    $httpProvider.interceptors.push("authInterceptor");
} ]), recipeRepoApp.run([ "localizationInitializer", function(localizationInitializer) {
    localizationInitializer.load();
} ]), recipeRepoApp.config([ "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise("/"), $stateProvider.state("login", {
        url: "/login",
        templateUrl: "app/components/login/login.html"
    }).state("home", {
        "abstract": !0,
        url: "/",
        templateUrl: "app/components/home/home.html"
    }).state("home.start", {
        url: "",
        templateUrl: "app/components/home/_start.html"
    }).state("home.search", {
        resolve: {
            searchQueryProvider: "searchQueryProvider"
        },
        params: {
            query: null
        },
        templateUrl: "app/components/home/_search.html"
    }).state("home.favorites", {
        templateUrl: "app/components/home/_favorites.html"
    }).state("recipe", {
        url: "/recipe/:recipeId",
        templateUrl: "/app/components/recipe/recipe-details.html"
    }).state("manage", {
        url: "/manage",
        templateUrl: "/app/components/manage/my-recipes.html"
    }).state("manage/create", {
        url: "/manage/create",
        templateUrl: "/app/components/manage/manage-recipe.html"
    }).state("manage/edit", {
        url: "/manage/edit/:recipeId",
        templateUrl: "/app/components/manage/manage-recipe.html"
    });
} ]), recipeRepoControllers.controller("favoritesController", [ "$scope", "userSession", "apiClient", function($scope, userSession, apiClient) {
    $scope.getFavoriteRecipes = function() {
        apiClient.getRecipes().then(function(recipes) {
            var user = userSession.get().user;
            $scope.recipes = recipes.findAll(function(r) {
                return user.favoriteRecipes.indexOf(r.id) > -1;
            });
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("homeController", [ "$scope", "$state", function($scope, $state) {
    $scope.search = function() {
        $state.go("home.search", {
            query: $scope.searchQuery
        });
    };
} ]), recipeRepoControllers.controller("searchController", [ "$scope", "$q", "$timeout", "searchQueryProvider", "apiClient", "localizationService", function($scope, $q, $timeout, searchQueryProvider, apiClient, localizationService) {
    function createSelectItems(source) {
        var mappedItems = source.map(function(c) {
            return {
                label: localizationService.translate("metaTags", c),
                value: c
            };
        });
        return mappedItems;
    }
    $scope.searchQuery = searchQueryProvider.getValue(), $scope.sortDirection = "asc", 
    $scope.showFilters = !1, $scope.searchQuery && $q.all([ apiClient.searchRecipes($scope.searchQuery), apiClient.getMetainfo() ]).then(function(responses) {
        $scope.hits = responses[0], $scope.readOnlyHits = responses[0], $scope.hasSearchHits = $scope.hits.length > 0;
        var metaInfo = responses[1];
        $scope.cuisines = createSelectItems(metaInfo.cuisines), $scope.categories = createSelectItems(metaInfo.categories), 
        $scope.courses = createSelectItems(metaInfo.courses);
    })["catch"](function() {
        $scope.hasError = !0;
    }), $scope.sort = function() {
        $scope.sortDirection = "asc" === $scope.sortDirection ? "desc" : "asc", $scope.hits = $scope.hits.sortBy(function(h) {
            return h.recipeName;
        }, "desc" === $scope.sortDirection);
    }, $scope.filter = function() {
        $scope.hits = $scope.readOnlyHits.findAll(function(h) {
            return !($scope.filteredCuisine && $scope.filteredCuisine.value !== h.meta.cuisine || $scope.filteredCategory && $scope.filteredCategory.value !== h.meta.category || $scope.filteredCourse && $scope.filteredCourse.value !== h.meta.course);
        });
    };
} ]), recipeRepoControllers.controller("startController", [ "$scope", "$state", "apiClient", function($scope, $state, apiClient) {
    function generateSections(recipes) {
        var historySection = {
            name: "history",
            items: recipes.sortBy(function(r) {
                return Date.create(r.meta.lastViewed);
            }, !0).to(4)
        }, latestSection = {
            name: "latest",
            items: recipes.sortBy(function(r) {
                return Date.create(r.created);
            }, !0).to(4)
        }, topRatedSection = {
            name: "topRated",
            items: recipes.sortBy(function(r) {
                return Date.create(r.rating);
            }, !0).to(4)
        };
        return [ historySection, latestSection, topRatedSection ];
    }
    $scope.createSections = function() {
        apiClient.getRecipes().then(function(recipes) {
            $scope.startSections = generateSections(recipes);
        })["catch"](function() {});
    };
} ]), recipeRepoControllers.controller("loginController", [ "$scope", "$state", "apiClient", function($scope, $state, apiClient) {
    $scope.onSubmit = function() {
        apiClient.login($scope.userName, $scope.password).then(function() {
            $state.go("home.start");
        })["catch"](function() {
            $scope.showError = !0;
        });
    };
} ]), recipeRepoControllers.controller("manageRecipeController", [ "$scope", "$q", "$stateParams", "apiClient", "localizationService", "log", function($scope, $q, $stateParams, apiClient, localizationService, log) {
    $scope.recipeId = $stateParams.recipeId, $scope.inEditMode = void 0 != $stateParams.recipeId, 
    $scope.currentRecipe = {
        meta: {}
    }, $scope.init = function() {
        var initPromises = [ apiClient.getMetainfo() ];
        $scope.inEditMode && initPromises.push(apiClient.getRecipe($scope.recipeId)), $q.all(initPromises).then(function(responses) {
            var metaInfo = responses[0], recipe = responses[1];
            recipe && ($scope.currentRecipe = recipe), $scope.cuisines = metaInfo.cuisines, 
            $scope.currentRecipe.meta.cuisine = $scope.cuisines[0], $scope.categories = metaInfo.categories, 
            $scope.currentRecipe.meta.category = $scope.categories[0], $scope.courses = metaInfo.courses, 
            $scope.currentRecipe.meta.course = $scope.courses[0];
        })["catch"](function() {
            $scope.hasError = !0;
        });
    }, $scope.getMetaLabel = function(value) {
        return localizationService.translate("metaTags", value);
    }, $scope.removeRow = function(index, model) {
        model.splice(index, 1);
    }, $scope.insertRow = function(index, model, initValue) {
        model.splice(index + 1, 0, initValue);
    }, $scope.onSubmit = function() {
        $scope.showError = !1, recipeForm.$invalid || ($scope.inEditMode ? ($scope.recipeUpdated = !1, 
        apiClient.updateRecipe($scope.currentRecipe).then(function() {
            $scope.recipeUpdated = !0, $scope.submitted = !1;
        })["catch"](function() {
            $scope.showError = !0;
        })) : ($scope.recipeCreated = !1, apiClient.addRecipe($scope.currentRecipe).then(function() {
            $scope.recipeCreated = !0, $scope.recipeForm.$setPristine(), $scope.submitted = !1, 
            $scope.currentRecipe = {
                ingredients: [ {} ],
                method: [ {} ]
            };
        })["catch"](function() {
            $scope.showError = !0;
        })));
    }, $scope.hasError = function(field) {
        var isInvalid = $scope.recipeForm[field].$invalid;
        return $scope.recipeForm[field].$dirty && isInvalid || $scope.submitted && isInvalid;
    };
} ]), recipeRepoControllers.controller("myRecipesController", [ "$scope", "apiClient", "userSession", function($scope, apiClient, userSession) {
    apiClient.getRecipes().then(function(recipes) {
        var user = userSession.get().user;
        $scope.recipes = recipes.findAll(function(r) {
            return user.ownedRecipes.indexOf(r.id) > -1;
        });
    })["catch"](function() {});
} ]), recipeRepoControllers.controller("recipeDetailsController", [ "$scope", "$stateParams", "$state", "userSession", "apiClient", "localizationService", function($scope, $stateParams, $state, userSession, apiClient, localizationService) {
    function formatRecipe(recipe) {
        return recipe.groupedIngredients = recipe.ingredients.groupBy(function(ing) {
            return ing.component;
        }), recipe.meta.cuisine = localizationService.translate("metaTags", recipe.meta.cuisine), 
        recipe.meta.category = localizationService.translate("metaTags", recipe.meta.category), 
        recipe.meta.course = localizationService.translate("metaTags", recipe.meta.course), 
        recipe;
    }
    $scope.modalHeading = localizationService.translate("recipeDetails", "confirmRemoveHeading"), 
    $scope.modalAction = localizationService.translate("recipeDetails", "confirmRemoveButton"), 
    $scope.initialize = function() {
        apiClient.getRecipe($stateParams.recipeId).then(function(recipe) {
            recipe.meta.lastViewed = Date.create(), apiClient.updateRecipe(recipe), $scope.recipe = formatRecipe(recipe);
            var user = userSession.get().user;
            $scope.isFavorite = user.favoriteRecipes.indexOf($scope.recipe.id) > -1, $scope.isEditable = user.ownedRecipes.indexOf($scope.recipe.id) > -1;
        })["catch"](function() {
            $scope.hasError = !0;
        });
    }, $scope.onFavoriteClick = function(e) {
        var isFavorite = $scope.isFavorite;
        if ($scope.isFavorite = !$scope.isFavorite, !isFavorite) {
            var user = userSession.get().user;
            user.favoriteRecipes.push($scope.recipe.id), apiClient.updateUser(user.userName, user).then(function(response) {
                $scope.recipe.isFavorite = recipe.isFavorite;
            });
        }
    }, $scope.removeRecipe = function() {
        apiClient.removeRecipe($scope.recipe.id).then(function() {
            $state.go("home.start");
        })["catch"](function() {
            $scope.hasError = !0;
        });
    };
} ]);

var Config = {
    appServerUrl: "localhost:8001"
};

recipeRepoDirectives.directive("rdAlert", [ "$window", function($window) {
    return {
        restrict: "E",
        scope: {
            type: "@",
            messageKey: "@",
            observe: "&"
        },
        link: function($scope, elem) {
            $scope.$watch($scope.observe, function(newValue, oldValue, scope) {
                $scope.visible = newValue === !0;
            }), elem.find(".close").on("click", function(e) {
                $scope.visible = !1, $scope.$apply();
            });
        },
        templateUrl: "/app/shared/alert/_alert.html"
    };
} ]), recipeRepoDirectives.directive("rdTranslate", function() {
    return {
        restrict: "AE",
        scope: {
            key: "@",
            attr: "@?"
        },
        controller: [ "$scope", "localizationService", function($scope, localizationService) {
            var keySegments = $scope.key.split("/");
            $scope.translatedValue = localizationService.translate(keySegments[0], keySegments[1]);
        } ],
        link: function(scope, elem, attrs) {
            var unwatch = scope.$watch("translatedValue", function(newValue) {
                newValue && (scope.attr ? elem.attr(scope.attr, newValue) : elem.text(newValue), 
                unwatch());
            });
        }
    };
}), recipeRepoServices.service("localizationInitializer", [ "$localStorage", "apiClient", function($localStorage, apiClient) {
    this.load = function() {
        apiClient.getTranslations().then(function(translations) {
            $localStorage.translations = translations;
        })["catch"](function(error) {});
    };
} ]), recipeRepoServices.service("localizationService", [ "$localStorage", function($localStorage) {
    this.translate = function(area, key) {
        var translations = $localStorage.translations;
        if (translations) {
            var matchingArea = translations[area];
            if (matchingArea) {
                var matchingTranslation = matchingArea[key];
                if (matchingTranslation) return matchingTranslation;
            }
        }
        return "[{1}/{2}]".assign(area, key);
    };
} ]), recipeRepoDirectives.directive("rdModal", [ "$window", function($window) {
    return {
        restrict: "E",
        transclude: !0,
        scope: {
            targetId: "@",
            modalHeader: "@",
            actionLabel: "@",
            onAction: "&"
        },
        controller: [ "$scope", function($scope) {
            $scope.actionInvoking = !1, $scope.invokeAction = function() {
                $scope.actionInvoking = !0, $scope.onAction();
            };
        } ],
        link: function(scope, elem) {
            var unwatch = scope.$watch("actionInvoking", function(newValue) {
                newValue === !0 && ($("#" + scope.targetId).modal("hide"), unwatch());
            });
        },
        templateUrl: "/app/shared/modal/_modal.html"
    };
} ]), recipeRepoDirectives.directive("rdNavbar", [ "$window", function($window) {
    return {
        restrict: "AE",
        controller: [ "$scope", "$state", "userSession", function($scope, $state, userSession) {
            var checkIsAuthenticated = function() {
                $scope.isAuthenticated = userSession.isValid(), $scope.isAuthenticated && ($scope.user = userSession.get().user);
            };
            checkIsAuthenticated(), $scope.$on("userSessionInitialized", checkIsAuthenticated), 
            $scope.$on("userSessionDisposed", checkIsAuthenticated), $scope.logout = function() {
                userSession.dispose(), $state.go("login");
            };
        } ],
        templateUrl: "/app/shared/navbar/_navbar.html"
    };
} ]), recipeRepoDirectives.directive("rdBackLink", [ "$window", "$state", function($window, $state) {
    return {
        restrict: "AE",
        scope: {
            targetState: "@",
            targetParams: "=?"
        },
        link: function(scope, elem) {
            elem.on("click", function() {
                scope.targetState ? $state.go(scope.targetState, scope.targetParams) : $window.history.back();
            });
        },
        template: '<a class="back"><i class="fa fa-chevron-left"></i> <rd-translate key="global/backLabel"></rd-translate></a>'
    };
} ]), recipeRepoServices.service("searchQueryProvider", [ "$stateParams", function($stateParams) {
    this.getValue = function() {
        return $stateParams.query || angular.element("#recipe-search").val();
    };
} ]), recipeRepoDirectives.directive("rdScroll", function() {
    return {
        restrict: "A",
        link: function(scope, $elem, $attr) {
            $elem.on("click", function() {
                var scrollPosition;
                switch ($attr.scrollTarget) {
                  case "top":
                    scrollPosition = $("body").offset().top;
                    break;

                  case "self":
                    scrollPosition = $elem.offset().top;
                    break;

                  default:
                    throw new Error("Invalid scroll target " + scope.target + ".");
                }
                $("body").animate({
                    scrollTop: scrollPosition
                }, 300);
            });
        }
    };
}), recipeRepoServices.service("apiClient", [ "$http", "$q", "log", function($http, $q, log) {
    var baseUrl = "http://" + Config.appServerUrl, apiUrl = baseUrl + "/api", onSuccess = function(action, response) {
        return log.debug(action + ": Successfully received response from API."), response.data;
    }, onError = function(action, error) {
        var errorMessage = error;
        error.data && (errorMessage = error.data.message || error.data);
        var formattedMsg = "{1}: an error occured{2}: {3}".assign(action, error.status && error.statusText ? " (" + error.status + " " + error.statusText + ")" : "", errorMessage);
        return log.error(formattedMsg), $q.reject({
            statusCode: error.status || -1,
            message: errorMessage
        });
    };
    this.login = function(userName, password) {
        return $http.post(baseUrl + "/auth/login", {
            userName: userName,
            password: password
        }).then(function(response) {
            return onSuccess("login", response);
        })["catch"](function(error) {
            return onError("login", error);
        });
    }, this.getRecipes = function() {
        return $http.get(apiUrl + "/recipes").then(function(response) {
            return onSuccess("getRecipes", response);
        })["catch"](function(error) {
            return onError("getRecipes", error);
        });
    }, this.getRecipe = function(id) {
        return $http.get(apiUrl + "/recipes/" + id).then(function(response) {
            return onSuccess("getRecipe", response);
        })["catch"](function(error) {
            return onError("getRecipe", error);
        });
    }, this.addRecipe = function(recipe) {
        return $http.post(apiUrl + "/recipes", {
            recipe: recipe
        }).then(function(response) {
            return onSuccess("addRecipe", response);
        })["catch"](function(error) {
            return onError("addRecipe", error);
        });
    }, this.updateRecipe = function(recipe) {
        return $http.post(apiUrl + "/recipes/" + recipe.id, {
            recipe: recipe
        }).then(function(response) {
            return onSuccess("updateRecipe", response);
        })["catch"](function(error) {
            return onError("updateRecipe", error);
        });
    }, this.removeRecipe = function(recipeId) {
        return $http["delete"](apiUrl + "/recipes/" + recipeId).then(function(response) {
            return onSuccess("removeRecipe", response);
        })["catch"](function(error) {
            return onError("removeRecipe", error);
        });
    }, this.searchRecipes = function(query) {
        return $http.post(apiUrl + "/recipes/search", {
            query: query
        }).then(function(response) {
            return onSuccess("searchRecipes", response);
        })["catch"](function(error) {
            return onError("searchRecipes", error);
        });
    }, this.getMetainfo = function() {
        return $http.get(apiUrl + "/meta").then(function(response) {
            return onSuccess("getMetainfo", response);
        })["catch"](function(error) {
            return onError("getMetainfo", error);
        });
    }, this.updateUser = function(userName, user) {
        return $http.post(apiUrl + "/user/" + userName, {
            user: user
        }).then(function(response) {
            return onSuccess("updateUser", response);
        })["catch"](function(error) {
            return onError("updateUser", error);
        });
    }, this.getTranslations = function() {
        return $http.get(apiUrl + "/lang/translations").then(function(response) {
            return onSuccess("translations", response);
        })["catch"](function(error) {
            return onError("translations", error);
        });
    };
} ]), recipeRepoApp.factory("authInterceptor", [ "$injector", "$q", "userSession", function($injector, $q, userSession) {
    return {
        request: function(config) {
            var session = userSession.get();
            return session && session.token && (config.headers = config.headers || {}, config.headers.Authorization = session.token), 
            config;
        },
        response: function(response) {
            return "object" == typeof response.data && response.data.token && userSession.initialize(response.data), 
            response;
        },
        responseError: function(response) {
            return 401 === response.status ? ($injector.get("$state").go("login"), $q.reject("User session has timed out.")) : $q.reject(response);
        }
    };
} ]), recipeRepoServices.service("log", [ "$log", function($log) {
    this.info = function(message) {
        $log.info(message);
    }, this.warn = function(message) {
        $log.warn(message);
    }, this.error = function(message) {
        "string" == typeof message ? $log.error(message) : $log.error("Cannot log error - illegal message type.");
    }, this.errorFormat = function(template) {
        var args = Array.prototype.slice.call(arguments, 1);
        this.error(template.assign.apply(template, args));
    }, this.debug = function(message) {
        $log.debug(message);
    };
} ]), recipeRepoServices.service("userSession", [ "$rootScope", "$sessionStorage", function($rootScope, $sessionStorage) {
    this.isValid = function() {
        return $sessionStorage.authSession && $sessionStorage.authSession.token;
    }, this.get = function() {
        return $sessionStorage.authSession;
    }, this.initialize = function(authSession) {
        $sessionStorage.authSession = authSession, $rootScope.$broadcast("userSessionInitialized");
    }, this.dispose = function() {
        delete $sessionStorage.authSession, $rootScope.$broadcast("userSessionDisposed");
    };
} ]);